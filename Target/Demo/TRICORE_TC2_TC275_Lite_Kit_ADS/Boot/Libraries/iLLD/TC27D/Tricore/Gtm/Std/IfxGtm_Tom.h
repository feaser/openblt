/**
 * \file IfxGtm_Tom.h
 * \brief GTM  basic functionality
 * \ingroup IfxLld_Gtm
 *
 * \version iLLD_1_0_1_16_1
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 *
 * \defgroup IfxLld_Gtm_Std_Tom Tom Basic Functionality
 * \ingroup IfxLld_Gtm_Std
 * \defgroup IfxLld_Gtm_Std_Tom_Enumerations TOM Enumerations
 * \ingroup IfxLld_Gtm_Std_Tom
 * \defgroup IfxLld_Gtm_Std_Tom_Channel_Functions TOM Channel Functions
 * \ingroup IfxLld_Gtm_Std_Tom
 * \defgroup IfxLld_Gtm_Std_Tom_TGC_Functions TOM TGC Functions
 * \ingroup IfxLld_Gtm_Std_Tom
 */

#ifndef IFXGTM_TOM_H
#define IFXGTM_TOM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxGtm_cfg.h"
#include "IfxGtm.h"
#include "IfxGtm_Tbu.h"
#include "Src/Std/IfxSrc.h"
#include "IfxGtm_bf.h"
#include "IfxGtm_Cmu.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Number of channels per TOM TGC
 */
#define IFXGTM_TOM_NUM_TGC_CHANNELS (8)

/** \brief Macro to calculate shift for each channel
 * Each channel occupies two bits hence multiply by 2 (left shift by 1) and then add offset
 */
#define IFXGTM_TOM_TGC_CHANNEL_SHIFT(channel, offset) ((((uint32)((uint32)channel & 0x7u)) << 1u) + offset)

/** \brief Macro to mask one channel bitfield in TGC registers
 */
#define IFXGTM_TOM_TGC_CHANNEL_MASK (3u)

/** \brief Macro to calculate channel bitfield value in TGC registers depending on whether it is enabled or not
 */
#define IFXGTM_TOM_TGC_CHANNEL_VALUE(enabled)         ((enabled == TRUE) ? IfxGtm_FeatureControl_enable : IfxGtm_FeatureControl_disable)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gtm_Std_Tom_Enumerations
 * \{ */
/** \brief Clock source for the TOM channels
 */
typedef enum
{
    IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0 = 0,  /**< \brief div 1 */
    IfxGtm_Tom_Ch_ClkSrc_cmuFxclk1 = 1,  /**< \brief div 16 */
    IfxGtm_Tom_Ch_ClkSrc_cmuFxclk2 = 2,  /**< \brief div 256 */
    IfxGtm_Tom_Ch_ClkSrc_cmuFxclk3 = 3,  /**< \brief div 4096 */
    IfxGtm_Tom_Ch_ClkSrc_cmuFxclk4 = 4,  /**< \brief div 32768 */
    IfxGtm_Tom_Ch_ClkSrc_noClock   = 5   /**< \brief no clock */
} IfxGtm_Tom_Ch_ClkSrc;

/** \brief Reset source for channel counter CN0
 */
typedef enum
{
    IfxGtm_Tom_Ch_OutputTrigger_forward  = 0, /**< \brief Forward the trigger from the previous channel */
    IfxGtm_Tom_Ch_OutputTrigger_generate = 1  /**< \brief Generate the trigger from the current channel */
} IfxGtm_Tom_Ch_OutputTrigger;

/** \brief Reset event for channel counter CN0
 */
typedef enum
{
    IfxGtm_Tom_Ch_ResetEvent_onCm0     = 0,
    IfxGtm_Tom_Ch_ResetEvent_onTrigger = 1
} IfxGtm_Tom_Ch_ResetEvent;

/** \} */

/** \addtogroup IfxLld_Gtm_Std_Tom_Channel_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Clears the channel One notification
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_clearOneNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Clears the channel Zero notification
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_clearZeroNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the base addredd of selected Tom channel
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return Pointer to channel base address
 */
IFX_INLINE Ifx_GTM_TOM_CH *IfxGtm_Tom_Ch_getChannelPointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the TOM channel input clock frequency in Hz
 * \param gtm Pointer to GTM module
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return TOM channel input clock frequency in Hz
 */
IFX_INLINE float32 IfxGtm_Tom_Ch_getClockFrequency(Ifx_GTM *gtm, Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the channel clock source
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return The clock source
 */
IFX_INLINE IfxGtm_Tom_Ch_ClkSrc IfxGtm_Tom_Ch_getClockSource(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the compare one value
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return compare one value
 */
IFX_INLINE uint32 IfxGtm_Tom_Ch_getCompareOne(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the compare one pointer
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return compare one pointer
 */
IFX_INLINE volatile uint32 *IfxGtm_Tom_Ch_getCompareOnePointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the compare zero value
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return compare zero value
 */
IFX_INLINE uint32 IfxGtm_Tom_Ch_getCompareZero(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the compare zero pointer
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return compare zero pointer
 */
IFX_INLINE volatile uint32 *IfxGtm_Tom_Ch_getCompareZeroPointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Gets the TOM output level
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return TRUE the output is high, FALSE the output is low
 */
IFX_INLINE boolean IfxGtm_Tom_Ch_getOutputLevel(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns a pointer to the TOM channel SRC
 * \param gtm Pointer to GTM module
 * \param tom Specifies the tom object
 * \param channel Channel index
 * \return Pointer to the TOM channel SRC
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxGtm_Tom_Ch_getSrcPointer(Ifx_GTM *gtm, IfxGtm_Tom tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the TGC pointer
 * \param tom Pointer to the TOM object
 * \param tgcIndex TGC index
 * \return TOM TGC object pointer
 */
IFX_INLINE Ifx_GTM_TOM_TGC *IfxGtm_Tom_Ch_getTgcPointer(Ifx_GTM_TOM *tom, uint32 tgcIndex);

/** \brief Returns the Timer pointer
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return Timer pointer
 */
IFX_INLINE volatile uint32 *IfxGtm_Tom_Ch_getTimerPointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the status of channel One notification
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return Status of channel One notification
 */
IFX_INLINE boolean IfxGtm_Tom_Ch_isOneNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Returns the status of channel Zero notification
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return Status of channel Zero notification
 */
IFX_INLINE boolean IfxGtm_Tom_Ch_isZeroNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Raises the interrupt for Compare 1
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_raiseInterruptOne(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Raises the interrupt for Compare 0
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_raiseInterruptZero(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel);

/** \brief Sets the channel clock source
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param clock Channel clock source
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setClockSource(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_Tom_Ch_ClkSrc clock);

/** \brief Sets the compare 0 and 1 values
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param compareZero Compare zero value
 * \param compareOne Compare one value
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setCompare(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 compareZero, uint32 compareOne);

/** \brief Sets the compare 1 value
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param compareOne Compare one value
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setCompareOne(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 compareOne);

/** \brief Sets the compare 1 shadow value
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param shadowOne Compare one shadow value
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setCompareOneShadow(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 shadowOne);

/** \brief Sets the compare 0 and 1 shadow values
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param shadowZero Compare zero shadow value
 * \param shadowOne Compare one shadow value
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setCompareShadow(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 shadowZero, uint32 shadowOne);

/** \brief Sets the compare 0 value
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param compareZero Compare zero value
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setCompareZero(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 compareZero);

/** \brief Sets the compare 0 shadow value
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param shadowZero Compare zero shadow value
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setCompareZeroShadow(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 shadowZero);

/** \brief Sets the counter value
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param value Counter value
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setCounterValue(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 value);

/** \brief Enable/disable the gated counter mode (channel 0 to 7 only)
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param enabled If TRUE, the feature is enabled, else disabled
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setGatedCounter(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, boolean enabled);

/** \brief Sets the channel notification
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param mode Interrupt mode
 * \param interruptOnCompareZero If TRUE, an interrupt is generated on compare 0, else no interrupt is generated
 * \param interruptOnCompareOne If TRUE, an interrupt is generated on compare 1, else no interrupt is generated
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_IrqMode mode, boolean interruptOnCompareZero, boolean interruptOnCompareOne);

/** \brief Enable/disable the one shot mode
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param enabled If TRUE, the feature is enabled, else disabled
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setOneShotMode(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, boolean enabled);

/** \brief Enable/disable the PCM mode (channel 15 only)
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param enabled If TRUE, the feature is enabled, else disabled
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setPcm(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, boolean enabled);

/** \brief Sets the channel clock source either from local or from previous channel
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param event Channel reset event
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setResetSource(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_Tom_Ch_ResetEvent event);

/** \brief Sets the signal level
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param activeState Signal level active state. In case the channel is reset, the output is set to not active. The signal is active between 0 and the leading edge (CM1) and inactive between the leading edge and the trailing edge (CM0).
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setSignalLevel(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, Ifx_ActiveState activeState);

/** \brief Enable/disable the SPE mode (channel 0 to 7 only)
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param enabled If TRUE, the feature is enabled, else disabled
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setSpe(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, boolean enabled);

/** \brief Sets the channel trigger output
 * \param tom Pointer to the TOM object
 * \param channel Channel index
 * \param trigger Channel trigger output mode
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Ch_setTriggerOutput(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_Tom_Ch_OutputTrigger trigger);

/** \} */

/** \addtogroup IfxLld_Gtm_Std_Tom_TGC_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable/disable one channel (ENDIS)
 * \param tgc Pointer to the TGC object
 * \param channel Channel index
 * \param enabled Enable/ Disable choise of the feature
 * \param immediate If TRUE, the action is done immediately else, the action is done on TGC trigger (CTRL_TRIG)
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_enableChannel(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled, boolean immediate);

/** \brief Enable/disable one channel output (OUTEN)
 * \param tgc Pointer to the TGC object
 * \param channel Channel index
 * \param enabled Enable/ Disable choise of the feature
 * \param immediate If TRUE, the action is done immediately else, the action is done on TGC trigger (CTRL_TRIG)
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelOutput(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled, boolean immediate);

/** \brief Enable/disable one channel for update (UPEN)
 * \param tgc Pointer to the TGC object
 * \param channel Channel index
 * \param enabled Enable/ Disable choise of the feature
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelUpdate(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled);

/** \brief Enable/disable one or more channels (ENDIS)
 * \param tgc Pointer to the TGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param immediate If TRUE, the action is done immediately else, the action is done on TGC trigger (CTRL_TRIG)
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_enableChannels(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask, boolean immediate);

/** \brief Enable/disable one or more channels output (OUTEN)
 * \param tgc Pointer to the TGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param immediate If TRUE, the action is done immediately else, the action is done on TGC trigger (CTRL_TRIG)
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelsOutput(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask, boolean immediate);

/** \brief Enable/disable the TGC channels trigger
 * \param tgc Pointer to the TGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelsTrigger(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask);

/** \brief Enable/disable one or more channels for update (UPEN)
 * \param tgc Pointer to the TGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelsUpdate(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask);

/** \brief Enable/disable the time base trigger
 * \param tgc Pointer to the TGC object
 * \param enabled If TRUE, the trigger is enabled else disabled
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_enableTimeTrigger(Ifx_GTM_TOM_TGC *tgc, boolean enabled);

/** \brief Enable/disable one channel for update (FUPD)
 * \param tgc Pointer to the TGC object
 * \param channel Channel index
 * \param enabled Enable/ Disable choise of the feature
 * \param resetEnabled Enable/ Disable reset choise of the feature
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_setChannelForceUpdate(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled, boolean resetEnabled);

/** \brief Enable/disable one or more channels for the force update feature (FUPD)
 * \param tgc Pointer to the TGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param resetEnableMask Mask for the enabled channels counter reset on force update (bit 0: Channel 0, bit 1: channel 1, ...) Channel 0, bit 1: channel 1, ...)
 * \param resetDisableMask Mask for the disabled channels with no counter reset on force update (bit 0: Channel 0, bit 1: channel 1, ...)
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_setChannelsForceUpdate(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask, uint16 resetEnableMask, uint16 resetDisableMask);

/** \brief Sets the trigger time base and time base value
 * \param tgc Pointer to the TGC object
 * \param base Time base used for comparison
 * \param value Compare value that raise the trigger
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_setTimeTrigger(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tbu_Ts base, uint32 value);

/** \brief Raise the trigger for the channel enable/disable settings,  output enable settings, and force update event (CTRL_TRIG)
 * \param tgc Pointer to the TGC object
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_trigger(Ifx_GTM_TOM_TGC *tgc);

/** \brief Sets the tgc global control value
 * \param tgc Pointer to the TGC object
 * \param control global control value
 * \return None
 */
IFX_INLINE void IfxGtm_Tom_Tgc_writeGlobalControl(Ifx_GTM_TOM_TGC *tgc, uint32 control);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Builds the register value for the feature enable/disable
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param bitfieldOffset Offset of the channel 0 bitfield in the register
 * \return The register value
 */
IFX_EXTERN uint32 IfxGtm_Tom_Tgc_buildFeature(uint16 enableMask, uint16 disableMask, uint8 bitfieldOffset);

/** \brief Builds the register value for the feature enable/disable for a single channel
 * \param channel Channel index
 * \param enabled Enable/ Disable choise of the feature
 * \param bitfieldOffset Offset of the channel 0 bitfield in the register
 * \return The register value
 */
IFX_EXTERN uint32 IfxGtm_Tom_Tgc_buildFeatureForChannel(IfxGtm_Tom_Ch channel, boolean enabled, uint8 bitfieldOffset);

/** \brief Reset one or more channels
 * \param tgc Pointer to the TGC object
 * \param resetMask Mask for the channel reset (bit 0: Channel 0, bit 1: channel 1, ...)
 * \return None
 */
IFX_EXTERN void IfxGtm_Tom_Tgc_resetChannels(Ifx_GTM_TOM_TGC *tgc, uint32 resetMask);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxGtm_Tom_Ch_clearOneNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    tomCh->IRQ_NOTIFY.B.CCU1TC = 1;
}


IFX_INLINE void IfxGtm_Tom_Ch_clearZeroNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    tomCh->IRQ_NOTIFY.B.CCU0TC = 1;
}


IFX_INLINE Ifx_GTM_TOM_CH *IfxGtm_Tom_Ch_getChannelPointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
}


IFX_INLINE float32 IfxGtm_Tom_Ch_getClockFrequency(Ifx_GTM *gtm, Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    IfxGtm_Tom_Ch_ClkSrc clk;
    IfxGtm_Cmu_Fxclk     clkIndex[5] = {
        IfxGtm_Cmu_Fxclk_0,      /*IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0 */
        IfxGtm_Cmu_Fxclk_1,      /*IfxGtm_Tom_Ch_ClkSrc_cmuFxclk1 */
        IfxGtm_Cmu_Fxclk_2,      /*IfxGtm_Tom_Ch_ClkSrc_cmuFxclk2 */
        IfxGtm_Cmu_Fxclk_3,      /*IfxGtm_Tom_Ch_ClkSrc_cmuFxclk3 */
        IfxGtm_Cmu_Fxclk_4       /*IfxGtm_Tom_Ch_ClkSrc_cmuFxclk4 */
    };

    clk = IfxGtm_Tom_Ch_getClockSource(tom, channel);

    if (clk == IfxGtm_Tom_Ch_ClkSrc_noClock)
    {
        return (float32)0.0f;
    }
    else
    {
        return IfxGtm_Cmu_getFxClkFrequency(gtm, clkIndex[clk], TRUE);
    }
}


IFX_INLINE IfxGtm_Tom_Ch_ClkSrc IfxGtm_Tom_Ch_getClockSource(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    IfxGtm_Tom_Ch_ClkSrc clk   = IfxGtm_Tom_Ch_ClkSrc_noClock;

    Ifx_GTM_TOM_CH      *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    clk = (IfxGtm_Tom_Ch_ClkSrc)tomCh->CTRL.B.CLK_SRC_SR;

    return clk;
}


IFX_INLINE uint32 IfxGtm_Tom_Ch_getCompareOne(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    return tomCh->CM1.U;
}


IFX_INLINE volatile uint32 *IfxGtm_Tom_Ch_getCompareOnePointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    return (volatile uint32 *)&tomCh->CM1.U;
}


IFX_INLINE uint32 IfxGtm_Tom_Ch_getCompareZero(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    return tomCh->CM0.U;
}


IFX_INLINE volatile uint32 *IfxGtm_Tom_Ch_getCompareZeroPointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    return (volatile uint32 *)&tomCh->CM0.U;
}


IFX_INLINE boolean IfxGtm_Tom_Ch_getOutputLevel(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    boolean         level;
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    level = (tomCh->STAT.B.OL == 1u) ? TRUE : FALSE;

    return level;
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxGtm_Tom_Ch_getSrcPointer(Ifx_GTM *gtm, IfxGtm_Tom tom, IfxGtm_Tom_Ch channel)
{
    IFX_UNUSED_PARAMETER(gtm)
    return &MODULE_SRC.GTM.GTM[0].TOM[tom][channel >> 1];
}


IFX_INLINE Ifx_GTM_TOM_TGC *IfxGtm_Tom_Ch_getTgcPointer(Ifx_GTM_TOM *tom, uint32 tgcIndex)
{
    Ifx_GTM_TOM_TGC *pointer;

    if (tgcIndex == 0)
    {
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC0_GLB_CTRL;
    }
    else
    {
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC1_GLB_CTRL;
    }

    return pointer;
}


IFX_INLINE volatile uint32 *IfxGtm_Tom_Ch_getTimerPointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    return (volatile uint32 *)&tomCh->CN0.U;
}


IFX_INLINE boolean IfxGtm_Tom_Ch_isOneNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    boolean         notify;
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    notify = (tomCh->IRQ_NOTIFY.B.CCU1TC != 0) ? TRUE : FALSE;
    return notify;
}


IFX_INLINE boolean IfxGtm_Tom_Ch_isZeroNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    boolean         notify;
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    notify = (tomCh->IRQ_NOTIFY.B.CCU0TC != 0u) ? TRUE : FALSE;
    return notify;
}


IFX_INLINE void IfxGtm_Tom_Ch_raiseInterruptOne(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    tomCh->IRQ_FORCINT.B.TRG_CCU1TC0 = 1u;
}


IFX_INLINE void IfxGtm_Tom_Ch_raiseInterruptZero(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    tomCh->IRQ_FORCINT.B.TRG_CCU0TC0 = 1u;
}


IFX_INLINE void IfxGtm_Tom_Ch_setClockSource(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_Tom_Ch_ClkSrc clock)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->CTRL.B.CLK_SRC_SR = (uint8)clock;
}


IFX_INLINE void IfxGtm_Tom_Ch_setCompare(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 compareZero, uint32 compareOne)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->CM0.U = compareZero;
    tomCh->CM1.U = compareOne;
}


IFX_INLINE void IfxGtm_Tom_Ch_setCompareOne(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 compareOne)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->CM1.U = compareOne;
}


IFX_INLINE void IfxGtm_Tom_Ch_setCompareOneShadow(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 shadowOne)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->SR1.U = shadowOne;
}


IFX_INLINE void IfxGtm_Tom_Ch_setCompareShadow(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 shadowZero, uint32 shadowOne)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->SR0.U = shadowZero;
    tomCh->SR1.U = shadowOne;
}


IFX_INLINE void IfxGtm_Tom_Ch_setCompareZero(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 compareZero)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->CM0.U = compareZero;
}


IFX_INLINE void IfxGtm_Tom_Ch_setCompareZeroShadow(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 shadowZero)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->SR0.U = shadowZero;
}


IFX_INLINE void IfxGtm_Tom_Ch_setCounterValue(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, uint32 value)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->CN0.U = value;
}


IFX_INLINE void IfxGtm_Tom_Ch_setGatedCounter(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, boolean enabled)
{
    if (channel <= IfxGtm_Tom_Ch_7)
    {
        Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

        tomCh->CTRL.B.GCM = (uint8)enabled;
    }
}


IFX_INLINE void IfxGtm_Tom_Ch_setNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_IrqMode mode, boolean interruptOnCompareZero, boolean interruptOnCompareOne)
{
    Ifx_GTM_TOM_CH       *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    Ifx_GTM_TOM_CH_IRQ_EN en;
    en.U = tomCh->IRQ_EN.U;

    /* Disable all interrupts of the interrupt set to change mode */
    tomCh->IRQ_EN.U            = IFX_ZEROS;
    tomCh->IRQ_MODE.B.IRQ_MODE = mode;
    tomCh->IRQ_EN.U            = en.U; /* Set the values back */

    en.B.CCU0TC_IRQ_EN         = interruptOnCompareZero ? 1 : 0;
    en.B.CCU1TC_IRQ_EN         = interruptOnCompareOne ? 1 : 0;
    tomCh->IRQ_EN.U            = en.U;
}


IFX_INLINE void IfxGtm_Tom_Ch_setOneShotMode(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, boolean enabled)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->CTRL.B.OSM = (uint8)enabled;
}


IFX_INLINE void IfxGtm_Tom_Ch_setPcm(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, boolean enabled)
{
    if (channel == IfxGtm_Tom_Ch_15)
    {
        tom->CH15.CTRL.B.BITREV = (uint8)enabled;
    }
}


IFX_INLINE void IfxGtm_Tom_Ch_setResetSource(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_Tom_Ch_ResetEvent event)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->CTRL.B.RST_CCU0 = (uint8)event;
}


IFX_INLINE void IfxGtm_Tom_Ch_setSignalLevel(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, Ifx_ActiveState activeState)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
}


IFX_INLINE void IfxGtm_Tom_Ch_setSpe(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, boolean enabled)
{
    if (channel <= IfxGtm_Tom_Ch_7)
    {
        Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

        tomCh->CTRL.B.SPEM = (uint8)enabled;
    }
}


IFX_INLINE void IfxGtm_Tom_Ch_setTriggerOutput(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_Tom_Ch_OutputTrigger trigger)
{
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    tomCh->CTRL.B.TRIGOUT = (uint8)trigger;
}


IFX_INLINE void IfxGtm_Tom_Tgc_enableChannel(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled, boolean immediate)
{
    uint32 shift = IFXGTM_TOM_TGC_CHANNEL_SHIFT(channel, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);

    uint32 value = (uint32)IFXGTM_TOM_TGC_CHANNEL_VALUE(enabled) << shift;
    uint32 mask  = (uint32)IFXGTM_TOM_TGC_CHANNEL_MASK << shift;

    Ifx__ldmst(&(tgc->ENDIS_CTRL.U), mask, value);

    if (immediate == TRUE)
    {
        Ifx__ldmst(&(tgc->ENDIS_STAT.U), mask, value);
    }
}


IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelOutput(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled, boolean immediate)
{
    uint32 shift = IFXGTM_TOM_TGC_CHANNEL_SHIFT(channel, IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_OFF);

    uint32 value = (uint32)IFXGTM_TOM_TGC_CHANNEL_VALUE(enabled) << shift;
    uint32 mask  = (uint32)((uint32)IFXGTM_TOM_TGC_CHANNEL_MASK << shift);

    Ifx__ldmst(&(tgc->OUTEN_CTRL.U), mask, value);

    if (immediate == TRUE)
    {
        Ifx__ldmst(&(tgc->OUTEN_STAT.U), mask, value);
    }
}


IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelUpdate(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled)
{
    tgc->GLB_CTRL.U = IfxGtm_Tom_Tgc_buildFeatureForChannel(channel, enabled, IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
}


IFX_INLINE void IfxGtm_Tom_Tgc_enableChannels(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask, boolean immediate)
{
    uint32 value;

    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);

    if (immediate)
    {
        tgc->ENDIS_CTRL.U = value;
        tgc->ENDIS_STAT.U = value;
    }
    else
    {
        tgc->ENDIS_CTRL.U = value;
    }
}


IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelsOutput(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask, boolean immediate)
{
    uint32 value;

    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_OFF);

    if (immediate)
    {
        tgc->OUTEN_CTRL.U = value;
        tgc->OUTEN_STAT.U = value;
    }
    else
    {
        tgc->OUTEN_CTRL.U = value;
    }
}


IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelsTrigger(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask)
{
    tgc->INT_TRIG.U = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_INT_TRIG_INT_TRIG0_OFF);
}


IFX_INLINE void IfxGtm_Tom_Tgc_enableChannelsUpdate(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask)
{
    tgc->GLB_CTRL.U = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
}


IFX_INLINE void IfxGtm_Tom_Tgc_enableTimeTrigger(Ifx_GTM_TOM_TGC *tgc, boolean enabled)
{
    tgc->ACT_TB.B.TB_TRIG = enabled ? 1 : 0;
}


IFX_INLINE void IfxGtm_Tom_Tgc_setChannelForceUpdate(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled, boolean resetEnabled)
{
    uint32 regEnable, regReset;

    regEnable        = IfxGtm_Tom_Tgc_buildFeatureForChannel(channel, enabled, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
    regReset         = IfxGtm_Tom_Tgc_buildFeatureForChannel(channel, resetEnabled, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);

    tgc->FUPD_CTRL.U = regEnable | (regReset);
}


IFX_INLINE void IfxGtm_Tom_Tgc_setChannelsForceUpdate(Ifx_GTM_TOM_TGC *tgc, uint16 enableMask, uint16 disableMask, uint16 resetEnableMask, uint16 resetDisableMask)
{
    uint32 regEnable, regReset;

    regEnable        = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
    regReset         = IfxGtm_Tom_Tgc_buildFeature(resetEnableMask, resetDisableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);

    tgc->FUPD_CTRL.U = regEnable | regReset;
}


IFX_INLINE void IfxGtm_Tom_Tgc_setTimeTrigger(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tbu_Ts base, uint32 value)
{
    Ifx_GTM_TOM_TGC0_ACT_TB act_tb;

    act_tb.U         = tgc->ACT_TB.U;
    act_tb.B.TBU_SEL = (uint8)base;
    act_tb.B.ACT_TB  = value;
    tgc->ACT_TB.U    = act_tb.U;
}


IFX_INLINE void IfxGtm_Tom_Tgc_trigger(Ifx_GTM_TOM_TGC *tgc)
{
    tgc->GLB_CTRL.U = 1 << IFX_GTM_TOM_TGC0_GLB_CTRL_HOST_TRIG_OFF;
}


IFX_INLINE void IfxGtm_Tom_Tgc_writeGlobalControl(Ifx_GTM_TOM_TGC *tgc, uint32 control)
{
    tgc->GLB_CTRL.U = control;
}


#endif /* IFXGTM_TOM_H */
